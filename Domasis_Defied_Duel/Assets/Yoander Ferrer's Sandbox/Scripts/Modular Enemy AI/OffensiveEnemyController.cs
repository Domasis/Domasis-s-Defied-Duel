
using System.Collections;
using UnityEngine;
using UnityEngine.AI;

[RequireComponent(typeof(NavMeshAgent))]
[RequireComponent(typeof(Animator))]
public class OffensiveEnemyController : LiveActor, TakesDamage, IHearSounds
{
    // IEnemyState derived class instances that contain the logic for each state the enemy is in.
    private static OnAttackState attackState = new();
    private static OnRoamState roamState = new();
    private static OnInvestigateState investigateState = new();

    [Header("Enemy Offensive Stats and State")]
    [SerializeField] private string currentStateName;
    private IEnemyState currentState;

    [Header("Animation and Motion")]
    [SerializeField] NavMeshAgent agent;
    [SerializeField] Animator animator;

    [Header("Roam Attributes")]

    [SerializeField] float roamDistance;

    [SerializeField] int roamTimer;

    [SerializeField] Vector3 minRoamDist;

    Vector3 origLocation;

    bool isRoaming, isInvestigating, isAttacking, wasHit, heardSomething;

    public bool IsRoaming { get => isRoaming; set => isRoaming = value; }
    public bool IsInvestigating { get => isInvestigating; set => isInvestigating = value; }
    public bool IsAttacking { get => isAttacking; set => isAttacking = value; }
    public float RoamDistance { get => roamDistance; set => roamDistance = value; }
    public int RoamTimer { get => roamTimer; set => roamTimer = value; }
    public Vector3 MinRoamDist { get => minRoamDist; set => minRoamDist = value; }
    public NavMeshAgent Agent { get => agent; set => agent = value; }
    public Animator Animator { get => animator; set => animator = value; }
    public string CurrentStateName { get => currentStateName; set => currentStateName = value; }
    public IEnemyState CurrentState { get => currentState; set => currentState = value; }
    public bool WasHit { get => wasHit; set => wasHit = value; }
    public bool HeardSomething { get => heardSomething; set => heardSomething = value; }
    public static OnAttackState AttackState { get => attackState; set => attackState = value; }
    public static OnRoamState RoamState { get => roamState; set => roamState = value; }
    public static OnInvestigateState InvestigateState { get => investigateState; set => investigateState = value; }
    public Vector3 OrigLocation { get => origLocation; set => origLocation = value; }

    // OnEnable is called once before the first execution of Start after the MonoBehaviour is created, as well as whenever a GameObject is enabled.
    void OnEnable()
    {
        CurrentState = RoamState;
    }

    new

    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        base.Start();

        if (Agent == null)
        {
            Agent = GetComponent<NavMeshAgent>();
        }

        if (Animator == null)
        {
            Animator = GetComponent<Animator>();
        }

        OrigLocation = transform.position;
    }

    // Update is called once per frame
    void Update()
    {
        ManageState();
    }

    public void TakeSomeDamage(int amount)
    { 
    
        
    
    }

    public void ReactToSound(Vector3 invokingLocation)
    {

    }

    // IEnumerator method that allows our AI to roam around its spawn point.
    public IEnumerator Roam()
    {
        // We set IsRoaming to true to prevent concurrent calls breaking our AI's ability to roam.
        IsRoaming = true;

        // We then pause execution of our method for a set amount of time.
        yield return new WaitForSeconds(RoamTimer);

        // We set our Agent's stopping distance to 0 to ensure it can reach its destination.
        Agent.stoppingDistance = 0;

        // We sample a random location within a minimum roam distance by generatng a random point inside of a unit sphere, multiplied by its allotted roam distance.
        Vector3 randomLoc = MinRoamDist + (Random.insideUnitSphere * RoamDistance);

        // We add this random location to our enemy's Original Location to ensure it's always roaming around the same area.
        randomLoc += OrigLocation;

        // We then sample the position generated by our previous calculations. The NavMeshHit generated will be populated with valid position data if the sampled location is valid.
        NavMesh.SamplePosition(randomLoc, out NavMeshHit hit, RoamDistance, 1);

        // We then set our destination for our Agent to this new hit position. If the position wasn't valid, this will simply not set a destination.
        Agent.SetDestination(hit.position);        

        IsRoaming = false;
    }

    IEnumerator FlashRed()
    {


        yield return new WaitForSeconds(0.2f);
    }

    void ManageState()
    {
        CurrentState = CurrentState.HandleState(this);
        CurrentStateName = CurrentState.ToString();
    }
}
